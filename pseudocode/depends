declare proc(T)

global_read
global_write

sem_init
sem_wait
sem_post
sem_getvalue

mutex_init
mutex_lock
mutex_unlock

pthread_create
pthread_join

enum visible_operation_type { 
	SEMAPHORE,
	MUTEX,
	GLOBAL_ACCESS,
	THREAD_SPAWN
}

Sequence of transitions -> some sort of list

struct transition { 
	mc_thread executor;
	visible_operation_type type;
	union { 
		mc_semaphore_op semaphore_op;
		mc_mutex mutex;
		mc_global global;
	}
};

enum mc_semaphore_op_code {SEM_INIT, SEM_WAIT, SEM_POST, ...};
struct mc_semaphore_op { 
	mc_semaphore semaphore;
};

enum global_state {GLOBAL_WRITE, GLOBAL_READ};
struct mc_global {
  void *raw_addr;
  enum global_state state;
};

enum mutex_state {MUTEX_LOCKED, MUTEX_UNLOCKED, MUTEX_UNKNOWN};
struct mc_mutex {
  pthread_mutex_t *mutex_addr;
  enum mutex_state state;
};

enum semaphore_state {SEMAPHORE_LOCKED, SEMAPHORE_UNLOCKED, SEMAPHORE_UNKNOWN};
struct mc_semaphore {
  int init_time;
  sem_t *semaphore_addr;
  int count; // negative is # of blocked threads; positive is # of free passes
};

def depends(tr1, tr2):
	if proc(tr1) == proc(tr2):
		return True
	
	if tr1 && tr2 are pthread operations:
		return depends_thread(tr1, tr2)

	if tr1.type == SEMAPHORE && tr2.type == SEMAPHORE:
		return depends_semaphore(tr1.semaphore_op, tr2.semaphore_op)

	if tr1.type == MUTEX && tr2.type == MUTEX:
		return depends_lock(tr1.mutex, tr2.mutex)
	
	if tr1.type == GLOBAL_ACCESS && tr2.type == GLOBAL_ACCESS:
		return depends_global(tr1.global, tr2.global)

	return False

# Assume different threads, same pthread created/waited on
def depends_thread(tr1, tr2):
	if tr1 == pthread_join && tr2 == pthread_join:
		return False
	elif tr1 == pthread_join || tr2 == pthread_join:
		return True
	
	# The case of two pthread_create s is probably undefined,
	# but possibly also impossible if we assume they can't
	# actually create the "same" thread
	return False

# Assume different threads, same semaphore
def depends_semaphore(tr1, tr2):
	
	if tr1 == sem_init && tr2 == sem_init:
		return False
	elif tr1 == sem_init || tr2 == sem_init:
		return True

	if tr1 == sem_getvalue && tr2 == sem_getvalue:
		return False
	elif tr1 == sem_getvalue || tr2 == sem_getvalue:
		return True
	
	if tr1 == sem_wait || tr2 == sem_wait:
		return True

	return False

# Assume different threads, same lock
def depends_lock(tr1, tr2):
	if tr1 == mutex_init && tr2 == mutex_init:
		return False
	elif tr1 == mutex_init || tr2 == mutex_init:
		return True

	if tr1 == mutex_lock || tr2 == mutex_lock:
		return True

	return False

# Assume different threads, same global variable
def depends_global(tr1, tr2):
	return tr1 == global_write || t2 == global_write

